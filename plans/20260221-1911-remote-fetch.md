# Remote Marketplace Fetching

**Goal:** Fetch a marketplace manifest from a remote source (HTTP URL or Git repo), validate it, and return a `MarketplaceManifest`. This enables testing our models against real-world marketplaces.

**Scope:** Read-only fetch + parse. No install, no write, no caching in v1.

---

## Design

### Two fetcher types

#### 1. HTTP fetcher
Fetches a `marketplace.json` directly from an HTTPS URL.

Use case: marketplace distributed as a raw file URL (e.g. a GitHub raw URL, a CDN, a self-hosted endpoint).

```
GET https://raw.githubusercontent.com/anthropics/claude-code/main/.claude-plugin/marketplace.json
→ parse response body as JSON → MarketplaceManifest
```

Dependency: `httpx` (preferred over `requests` — sync + async, modern API, no extra deps).

#### 2. Git fetcher
Clones a repository to a temp directory, then reads `.claude-plugin/marketplace.json` from it.

Use case: GitHub/GitLab hosted marketplaces (the primary Claude Code distribution pattern).

```
git clone --depth 1 --branch <ref> <url> <tmpdir>
→ load_marketplace(tmpdir) → MarketplaceManifest
```

Implementation: `subprocess` calling `git`. No `gitpython` — fewer deps, `git` is always available.

---

### Source types (mirror what the JSON schema already defines)

```python
# Already in models/marketplace.py — reuse these
GitHubSource(repo="anthropics/claude-code", ref="main")
URLSource(url="https://gitlab.com/example/plugins.git")
# New: plain HTTPS URL to a raw JSON file
HTTPSource(url="https://example.com/.claude-plugin/marketplace.json")
```

### New public API

```python
# Async (recommended)
await fetch_marketplace(source) -> MarketplaceManifest

# Sync convenience wrapper
fetch_marketplace_sync(source) -> MarketplaceManifest
```

`source` accepts:
- `str` — auto-detected: ends with `.git` → git clone, otherwise → HTTP GET
- `GitHubSource` — git clone from `github.com/<repo>`
- `URLSource` — git clone from `.url`
- `HTTPSource` — direct HTTP GET

---

## Package layout changes

```
src/claude_code_plugins_sdk/
├── fetchers/
│   ├── __init__.py          ← fetch_marketplace, fetch_marketplace_sync
│   ├── _http.py             ← _fetch_via_http(url) → MarketplaceManifest
│   └── _git.py              ← _fetch_via_git(url, ref, sha) → MarketplaceManifest
└── models/
    └── marketplace.py       ← add HTTPSource
```

Add `HTTPSource` to `models/marketplace.py`:
```python
class HTTPSource(BaseModel):
    source: Literal["http"]
    url: str   # direct URL to marketplace.json
```

Update `models/__init__.py` and `__init__.py` to export `HTTPSource` and the new fetchers.

---

## Error handling

Extend `errors.py`:

```python
class FetchError(Exception):
    """Raised when a remote fetch fails (network, git, HTTP error)."""
    def __init__(self, message: str, url: str | None = None) -> None:
        self.url = url
        super().__init__(message)
```

`FetchError` covers: network errors, HTTP 4xx/5xx, git clone failure, timeout.  
`pydantic.ValidationError` still bubbles up as-is if the remote content is valid JSON but fails schema validation.

---

## Implementation notes

### HTTP (`_http.py`)

- Use `httpx.get(url, follow_redirects=True, timeout=30)`
- Raise `FetchError` on `httpx.HTTPError` or non-2xx status
- Parse response as JSON, validate with `MarketplaceManifest.model_validate()`

### Git (`_git.py`)

- Use `tempfile.TemporaryDirectory()` as clone target (auto-cleaned up)
- Build git URL from source:
  - `GitHubSource` → `https://github.com/<repo>.git`
  - `URLSource` → use `.url` directly
- Run: `git clone --depth 1 [--branch <ref>] <url> <tmpdir>`
- Optionally verify SHA after clone if `sha` is set
- Call `load_marketplace(Path(tmpdir))` from existing loaders
- Raise `FetchError` if git exits non-zero

### Auto-detection from string

```python
def _detect_source(s: str) -> HTTPSource | GitHubSource | URLSource:
    if s.endswith(".git"):
        return URLSource(source="url", url=s)
    if re.match(r"^[\w-]+/[\w-]", s):  # "owner/repo" shorthand
        return GitHubSource(source="github", repo=s)
    return HTTPSource(source="http", url=s)
```

---

## New dependency

```
httpx>=0.27
```

`git` must be available in `$PATH` (standard assumption — it's on every dev machine and CI).

---

## Tests

### Unit tests (`tests/test_fetchers.py`)

Use `httpx`'s `MockTransport` / `respx` to mock HTTP. Use `tmp_path` + subprocess mock for git.

Actually: for git tests, create a real local git repo in `tmp_path` with a `marketplace.json`, then test `_fetch_via_git` pointing at it via `file://` URL. No network needed.

```python
def test_fetch_via_http_success(httpx_mock):
    httpx_mock.add_response(json={...valid marketplace data...})
    result = fetch_marketplace_sync(HTTPSource(source="http", url="https://example.com/marketplace.json"))
    assert result.name == "..."

def test_fetch_via_http_404(httpx_mock):
    httpx_mock.add_response(status_code=404)
    with pytest.raises(FetchError):
        fetch_marketplace_sync(HTTPSource(...))

def test_fetch_via_git_local(tmp_path):
    # create a local git repo with marketplace.json, fetch via file:// URL
    ...

def test_fetch_string_auto_detect():
    # test the string dispatcher
    ...
```

Add `pytest-httpx` as a dev dependency for HTTP mocking.

### Integration test (optional, skipped by default)

```python
@pytest.mark.integration
def test_fetch_anthropic_official_marketplace():
    m = fetch_marketplace_sync("anthropics/claude-code")
    assert m.name == "claude-code-plugins"
    assert len(m.plugins) > 0
```

Run with `uv run pytest -m integration` — skipped in normal CI.

---

## Parallelization

These are fully independent:

| Agent A | Agent B |
|---|---|
| `models/marketplace.py` — add `HTTPSource` | `tests/test_fetchers.py` — write test cases |
| `fetchers/_http.py` + `fetchers/__init__.py` | (wait for A to finish, then run) |
| `fetchers/_git.py` | |
| `errors.py` — add `FetchError` | |
| Update `__init__.py` + `models/__init__.py` | |

Agent A does all implementation. Agent B writes tests once Agent A is done.

---

## Done when

- [ ] `uv run pytest` passes (unit tests, no network)
- [ ] `uv run pytest -m integration` passes against Anthropic's real marketplace
- [ ] `uv run mypy src/` exits 0
- [ ] `uv run ruff check src/ tests/` exits 0
- [ ] `fetch_marketplace_sync("anthropics/claude-code")` returns a valid `MarketplaceManifest` with 10+ plugins
