# Phase 1 SDK — Core Models & Loaders

**Goal:** A working Python library that can load a marketplace file and a plugin directory, validate them against the official Claude Code schema, and expose typed Python objects.

**Scope:** Read-only. No HTTP, no installs, no CLI.

---

## What to build

### 1. Package skeleton

`src/claude_code_plugins_sdk/` with a `src` layout (already scaffolded by uv).

```
src/claude_code_plugins_sdk/
├── __init__.py          ← re-export the public API
├── errors.py            ← LoadError
├── models/
│   ├── __init__.py
│   ├── plugin.py        ← PluginManifest, Author
│   ├── marketplace.py   ← MarketplaceManifest, PluginEntry, source types
│   ├── agent.py         ← AgentDefinition
│   ├── skill.py         ← SkillDefinition
│   ├── command.py       ← CommandDefinition
│   ├── hook.py          ← HooksConfig, HookEvent, HookEntry
│   ├── mcp.py           ← MCPServersConfig
│   └── lsp.py           ← LSPServersConfig
├── loaders/
│   ├── __init__.py
│   ├── marketplace.py   ← load_marketplace(path)
│   └── plugin.py        ← load_plugin(path) → Plugin
└── _plugin.py           ← Plugin dataclass (domain object)
```

### 2. Models

All models are Pydantic v2 with `model_config = ConfigDict(extra="allow", populate_by_name=True)`.
Never break on unknown fields — the ecosystem evolves.

#### `plugin.py` — `.claude-plugin/plugin.json`

```python
class Author(BaseModel):
    name: str
    email: str | None = None
    url: str | None = None

class PluginManifest(BaseModel):
    name: str
    version: str | None = None
    description: str | None = None
    author: Author | None = None
    homepage: str | None = None
    repository: str | None = None
    license: str | None = None
    keywords: list[str] = []
    # component paths — each can be str, list[str], or dict (inline config)
    commands: str | list[str] | None = None
    agents: str | list[str] | None = None
    skills: str | list[str] | None = None
    hooks: str | list[str] | dict[str, Any] | None = None
    mcp_servers: str | list[str] | dict[str, Any] | None = Field(None, alias="mcpServers")
    output_styles: str | list[str] | None = Field(None, alias="outputStyles")
    lsp_servers: str | list[str] | dict[str, Any] | None = Field(None, alias="lspServers")
```

#### `marketplace.py` — `.claude-plugin/marketplace.json`

Plugin source is a discriminated union. A plain string is a relative path.
Object sources are discriminated on the `source` field: `"github"`, `"url"`, `"npm"`, `"pip"`.

```python
class GitHubSource(BaseModel):
    source: Literal["github"]
    repo: str          # "owner/repo"
    ref: str | None = None
    sha: str | None = None

class URLSource(BaseModel):
    source: Literal["url"]
    url: str           # must end with .git
    ref: str | None = None
    sha: str | None = None

class NPMSource(BaseModel):
    source: Literal["npm"]
    package: str
    version: str | None = None
    registry: str | None = None

class PIPSource(BaseModel):
    source: Literal["pip"]
    package: str
    version: str | None = None
    registry: str | None = None

PluginSource = Annotated[
    GitHubSource | URLSource | NPMSource | PIPSource,
    Field(discriminator="source")
]

class MarketplaceOwner(BaseModel):
    name: str
    email: str | None = None

class MarketplaceMetadata(BaseModel):
    description: str | None = None
    version: str | None = None
    plugin_root: str | None = Field(None, alias="pluginRoot")

class PluginEntry(BaseModel):
    # source is str (relative path) OR one of the typed source objects
    name: str
    source: str | PluginSource
    description: str | None = None
    version: str | None = None
    author: Author | None = None
    homepage: str | None = None
    repository: str | None = None
    license: str | None = None
    keywords: list[str] = []
    category: str | None = None
    tags: list[str] = []
    strict: bool = True
    # inline component paths (same as PluginManifest)
    commands: ...
    agents: ...
    hooks: ...
    mcp_servers: ...
    lsp_servers: ...

class MarketplaceManifest(BaseModel):
    schema_url: str | None = Field(None, alias="$schema")
    name: str
    version: str | None = None
    description: str | None = None
    owner: MarketplaceOwner
    metadata: MarketplaceMetadata | None = None
    plugins: list[PluginEntry]
```

#### `agent.py` — `agents/*.md` frontmatter

The `tools` field is a **comma-separated string** in the YAML, not a list. Parse it in a validator.

```python
class AgentDefinition(BaseModel):
    name: str
    description: str
    tools: list[str] = []   # stored as "Read, Write, Bash" in YAML
    color: str | None = None
    body: str = ""          # markdown body (the agent system prompt)

    @field_validator("tools", mode="before")
    @classmethod
    def parse_tools_string(cls, v):
        if isinstance(v, str):
            return [t.strip() for t in v.split(",") if t.strip()]
        return v
```

#### `skill.py` — `skills/<name>/SKILL.md` frontmatter

```python
class SkillDefinition(BaseModel):
    description: str | None = None
    name: str | None = None
    disable_model_invocation: bool = Field(False, alias="disable-model-invocation")
    body: str = ""
```

#### `command.py` — `commands/*.md` frontmatter

Note: `allowed-tools` is a **YAML list**, not a comma-separated string (opposite of agents).

```python
class CommandDefinition(BaseModel):
    name: str | None = None
    description: str | None = None
    argument_hint: str | None = Field(None, alias="argument-hint")
    allowed_tools: list[str] = Field([], alias="allowed-tools")
    agent: str | None = None
    body: str = ""
```

#### `hook.py` — `hooks/hooks.json`

```python
class HookEntry(BaseModel):
    type: Literal["command", "prompt", "agent"]
    command: str | None = None   # for type="command"
    prompt: str | None = None    # for type="prompt"
    agent: str | None = None     # for type="agent"

class HookMatcher(BaseModel):
    matcher: str | None = None
    hooks: list[HookEntry]

HookEvent = Literal[
    "PreToolUse", "PostToolUse", "PostToolUseFailure",
    "SessionStart", "SessionEnd",
    "SubagentStart", "SubagentStop",
    "Stop", "Notification",
    "UserPromptSubmit", "PermissionRequest",
    "PreCompact", "TaskCompleted", "TeammateIdle",
]

class HooksConfig(BaseModel):
    hooks: dict[str, list[HookMatcher]]  # event name → matchers
```

#### `mcp.py` — `.mcp.json`

```python
class MCPServerConfig(BaseModel):
    command: str
    args: list[str] = []
    env: dict[str, str] = {}
    cwd: str | None = None

class MCPServersConfig(BaseModel):
    mcp_servers: dict[str, MCPServerConfig] = Field({}, alias="mcpServers")
```

#### `lsp.py` — `.lsp.json`

```python
class LSPServerConfig(BaseModel):
    command: str
    extension_to_language: dict[str, str] = Field({}, alias="extensionToLanguage")
    args: list[str] = []
    transport: Literal["stdio", "socket"] = "stdio"
    env: dict[str, str] = {}
    # ... other optional fields

LSPServersConfig = dict[str, LSPServerConfig]
```

### 3. `Plugin` domain object

```python
@dataclass
class Plugin:
    root: Path
    manifest: PluginManifest | None
    agents: list[AgentDefinition]
    commands: list[CommandDefinition]
    skills: list[SkillDefinition]
    hooks: HooksConfig | None
    mcp_servers: MCPServersConfig | None
    lsp_servers: LSPServersConfig | None
```

### 4. Loaders

#### `load_marketplace(path: Path) -> MarketplaceManifest`

- If `path` is a file: load it directly as JSON
- If `path` is a directory: look for `.claude-plugin/marketplace.json` inside it
- Parse with `json.loads`, validate with `MarketplaceManifest.model_validate(data)`
- Raise `LoadError` for missing files or JSON parse failures
- Let `pydantic.ValidationError` bubble up as-is

#### `load_plugin(path: Path) -> Plugin`

- `path` must be a directory (the plugin root)
- Load `.claude-plugin/plugin.json` if present (optional)
- Discover agents in `agents/*.md` using `python-frontmatter`
- Discover commands in `commands/*.md`
- Discover skills in `skills/*/SKILL.md`
- Load `hooks/hooks.json` if present
- Load `.mcp.json` if present
- Load `.lsp.json` if present
- Return `Plugin` dataclass

#### `load_agent(path: Path) -> AgentDefinition` / `load_skill(path)` / etc.

Individual loaders for each component — used internally by `load_plugin` but also exposed publicly.

### 5. Public API (`__init__.py`)

```python
from .loaders.marketplace import load_marketplace
from .loaders.plugin import load_plugin, load_agent, load_skill, load_command
from .models import *
from ._plugin import Plugin
from .errors import LoadError
```

### 6. `errors.py`

```python
class LoadError(Exception):
    def __init__(self, message: str, path: Path | None = None):
        self.path = path
        super().__init__(message)
```

---

## Tests

Test files mirror the modules. Use `tests/fixtures/` for real example files.

### Fixtures to create

**`tests/fixtures/marketplace/.claude-plugin/marketplace.json`**  
A full marketplace with one plugin per source type (relative, github, url, npm, pip).

**`tests/fixtures/plugin/.claude-plugin/plugin.json`**  
A full plugin manifest.

**`tests/fixtures/plugin/agents/reviewer.md`**  
Agent with `tools` as comma-separated string and a body.

**`tests/fixtures/plugin/skills/code-review/SKILL.md`**  
Skill with frontmatter.

**`tests/fixtures/plugin/commands/review.md`**  
Command with `allowed-tools` as a YAML list.

**`tests/fixtures/plugin/hooks/hooks.json`**  
Hook config with PostToolUse and SessionStart.

**`tests/fixtures/plugin/.mcp.json`**  
MCP server config.

**`tests/fixtures/plugin/.lsp.json`**  
LSP server config.

### Test files

- `tests/test_models_marketplace.py` — parse all source types, required field validation
- `tests/test_models_plugin.py` — parse plugin manifest
- `tests/test_models_components.py` — agent tools string, command allowed-tools list, skill frontmatter
- `tests/test_loaders.py` — load_marketplace from file and directory, load_plugin end-to-end
- `tests/test_errors.py` — LoadError on missing file, ValidationError on bad schema

---

## How to parallelize

These tasks have no dependencies on each other and can be done in parallel:

| Track A | Track B | Track C |
|---|---|---|
| `models/plugin.py` | `models/agent.py` | test fixtures (JSON/MD files) |
| `models/marketplace.py` | `models/skill.py` + `models/command.py` | |
| `models/hook.py` + `models/mcp.py` + `models/lsp.py` | `errors.py` | |

Then in parallel:
- `loaders/marketplace.py` (depends on marketplace model)
- `loaders/plugin.py` + `_plugin.py` (depends on all models)

Finally:
- `__init__.py` (depends on everything)
- All test files (can be written alongside their corresponding module)

---

## Validation

```bash
# run tests
uv run pytest

# type check
uv run mypy src/

# lint
uv run ruff check src/ tests/

# compare against claude CLI
claude plugin validate tests/fixtures/marketplace
claude plugin validate tests/fixtures/plugin
```

The Claude CLI's `claude plugin validate` command is the ground truth. If our validation rejects something the CLI accepts, we're wrong. If we accept something the CLI rejects, we should add a validator.

---

## Done when

- [ ] `uv run pytest` passes with >90% coverage
- [ ] `uv run mypy src/` exits 0
- [ ] `uv run ruff check src/ tests/` exits 0
- [ ] `load_marketplace("tests/fixtures/marketplace")` returns a valid `MarketplaceManifest`
- [ ] `load_plugin("tests/fixtures/plugin")` returns a `Plugin` with agents, skills, etc.
- [ ] `claude plugin validate tests/fixtures/marketplace` passes
- [ ] `claude plugin validate tests/fixtures/plugin` passes
